from cli_oauth_authorization_server_sign_jwt import sign_jwt
import urllib.parse
from render import render_main
from markupsafe import Markup
import urllib.parse
import json
import base64
import helper_pkce
from store_oauth_authorization_server_codes import (
    get_and_delete_code_value,
    put_code_value,
    get_code_value,
    CodeValue,
    set_code_sub,
)
from store_oauth_authorization_server_session import (
    put_session_value,
    SessionValue,
    get_session_value,
)
import os
from http import cookies
from route_oauth_resource_owner_api import apis

available_scopes = []
for api in apis:
    for required_scope in apis[api][1]:
        if required_scope not in available_scopes:
            available_scopes.append(required_scope)
print(available_scopes)

store_dir = os.environ.get("STORE_DIR", "./store")
oauth_authorization_server_store_dir = os.path.join(
    store_dir, "oauth_authorization_server"
)
os.makedirs(oauth_authorization_server_store_dir, exist_ok=True)
clients_json_path = os.path.join(oauth_authorization_server_store_dir, "clients.json")

with open(clients_json_path, "r") as fp:
    parsed = json.loads(fp.read())
    client_credentials_clients = parsed["client_credentials"]
    code_clients = parsed["code"]


def oauth_token(http):
    # For client credentials
    # See https://datatracker.ietf.org/doc/html/rfc6749#section-4.4
    # grant_type=client_credentials
    # Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
    # get client id/client secret
    # return access_token
    # curl -H 'Authorization: Basic client:secret' -v http://localhost:16000/oauth/token?grant_type=client_credentials
    http.response.status = "400 Bad Request"
    http.response.headers["content-type"] = "application/json;charset=UTF-8"
    http.response.headers["cache-control"] = "no-store"
    http.response.headers["pragma"] = "no-cache"

    q = urllib.parse.parse_qs(
        http.request.query,
        keep_blank_values=False,
        strict_parsing=True,
        encoding="utf-8",
        max_num_fields=10,
        separator="&",
    )
    assert len(q) >= 1, "Unexpected query string length"
    assert "grant_type" in q
    assert len(q["grant_type"]) == 1
    grant_type = q["grant_type"][0]
    assert grant_type in ["client_credentials", "code"]

    if grant_type == "client_credentials":
        # http.request.query != 'grant_type=client_credentials':
        # http.response.body = {'error': 'invalid_request', 'error_description': "Expected only 'grant_type=client_credentials' as the query string"}
        # return
        creds = http.request.headers.get("authorization", "").strip()
        if creds[:6].lower() != "basic ":
            # Perhaps this should be a 401? https://datatracker.ietf.org/doc/html/rfc6749#section-5.1
            http.response.body = {
                "error": "invalid_request",
                "error_description": "Expected basic Authorization header",
            }
            return
        print(creds[6:])
        print(base64.b64decode(creds[6:] + "=="))
        client_id, secret = base64.b64decode(creds[6:] + "==").decode("utf8").split(":")
        # XXX This isn't quite right
        sub = client_id
        if secret != client_credentials_clients[client_id]["secret"]:
            http.response.body = {
                "error": "invalid_client",
                "error_description": "Invalid credentials",
            }
            return
        scopes = client_credentials_clients[client_id]["scopes"]
    elif grant_type == "code":
        assert "code" in q
        assert len(q["code"]) == 1
        assert "code_verifier" in q
        assert len(q["code_verifier"]) == 1
        code = q["code"][0]
        code_verifier = q["code_verifier"][0]
        code_value = get_and_delete_code_value(code)
        if code_value.sub is None or code_value.scopes is None:
            raise Exception("Not completed auth flow before trying to get token")
        client_id = code_value.client_id
        code_challenge = code_value.code_challenge
        scopes = code_value.scopes
        sub = code_value.sub
        print(
            code,
            code_verifier,
            code_value.client_id,
            code_value.code_challenge,
            code_value.sub,
        )
        # This is the key check - if the code_challenge we recieved at the start can be generated from this code verifier, it is the same client and we can issue a token.
        assert helper_pkce.code_challenge(code_verifier) == code_value.code_challenge
    expires_in = 600
    http.response.status = "200 OK"
    http.response.body = {
        "access_token": sign_jwt(
            client_id=client_id, sub=sub, expires_in=expires_in, scopes=scopes
        ),
        "token_type": "bearer",
        "expires_in": expires_in,
    }


def _make_url(code, code_value):
    url = code_clients[code_value.client_id]["redirect_uri"] + "?"
    if code_value.state:
        url += "state=" + urllib.parse.quote(code_value.state)
        url += "&code=" + urllib.parse.quote(code)
    else:
        url += "code=" + urllib.parse.quote(code)
    return url

def _consent(http, session):
    return True

def oauth_authorize(http):
    q = urllib.parse.parse_qs(
        http.request.query,
        keep_blank_values=False,
        strict_parsing=True,
        encoding="utf-8",
        max_num_fields=10,
        separator="&",
    )
    assert len(q) >= 5, "Unexpected query string length"
    assert len(q["response_type"]) == 1
    assert q["response_type"][0] == "code", "response_type != code"
    assert len(q["code_challenge_method"]) == 1
    assert q["code_challenge_method"][0] == "S256", "code_challenge != S256"
    assert len(q["code_challenge"]) == 1
    assert len(q["client_id"]) == 1
    client_id = q["client_id"][0]
    assert client_id in code_clients, "Unknown client"
    scopes = []
    if "scope" in q:
        for scope in q["scope"][0].split(" "):
            assert scope in available_scopes, "Not a known scope: " + scope
            scopes.append(scope)
    state = None
    if "state" in q:
        assert len(q["state"]) == 1
        state = q["state"][0]

    authorize_state = dict(
        client_id=client_id,
        code_challenge=code_challenge=q["code_challenge"][0],
        scopes=scopes,
        state=state,
    )
    # There are three things to do here:
    # 3. User is signed and has not already granted consent -> In this case they may be at this screen for two different flows. This means the session or the data must be keyed by the client id
    session_id = _get_session_id(http, "oauth")
    if session_id:
        session = get_session_value(session_id)
        if _consent(http, session):
            # 1. User is signed in and given consent -> create code and redirect straight away with new code
            # UNLESS there are multiple flows in progress. Then need to offer a choice.
            new_code = helper_pkce.code_verifier()
            code_value = CodeValue(sub=session.sub, authorize_state=authorize_state)
            put_code_value(new_code, code_value)
            url = _make_url(new_code, code_value)
            http.response.status = "302 Redirect"
            http.response.headers["location"] = url
            http.response.body = "Redirecting ..."
        else:
            # They might be on two pages at once, both asking for consent.
            # If so we say that the more recent one takes precedence (it will overwrite its session value) so the consent form should have a hidden field that ties it to the session, a CSRF token basically.
            # This needs to be in the session at that point
            # If you submit a consent without a matching token, give an error

            # Or better

            # Just have a token that is kept on the query string of the consent form that keys the different authorized_states and subs
            # Then make sure the consent form passes it too, then use it to decide which authorize request to continue with. (Could actually use the code challenge or the state, but shouldn't)

            # This would be much easier if we could trust relay state from SAML or state from OIDC, because then we wouldn't bother with it.

            # Or it would also be easy if the consent screen asked you which you wanted to continue with, which would allow you to swap browser too.

            csrf = helper_pkce.code_verifier()
            put_session_value(session_id, SessionValue(authorize_state=authorize_state, csrf=csrf))
            http.response.body = Markup(
                '<html><head><meta http-equiv="refresh" content="0; url={path}"></head><body><a href="{path}"></a></body></html>'
            ).format(path="/oauth/consent")
    else:
        # 2. User is not sigend in -> create a session, store query string params, redirect to handle login, then at the end use the session to obtain the details to create new code and redirect
        session_id = _login(http, "oauth")
        csrf = helper_pkce.code_verifier()
        put_session_value(session_id, SessionValue(authorize_state=authorize_state, csrf=csrf))
        http.response.body = Markup(
            '<html><head><meta http-equiv="refresh" content="0; url={path}"></head><body><a href="{path}"></a></body></html>'
        ).format(path="/oauth/login")


def _get_session_id(http, name):
    cookie = cookies.SimpleCookie()
    if "cookie" in http.request.headers:
        cookie.load(http.request.headers["cookie"])
    if name in cookie:
        return cookie[name].value
    return None


def _login(http, name):
    session = helper_pkce.code_verifier()
    cookie = cookies.SimpleCookie()
    if "cookie" in http.request.headers:
        cookie.load(http.request.headers["cookie"])
    cookie[name] = session
    # cookie['oauth']['expires'] =
    cookie[name]["path"] = "/"
    cookie[name]["comment"] = "upstream oauth"
    cookie[name][
        "domain"
    ] = "localhost"  # Can't use the port here https://datatracker.ietf.org/doc/html/rfc2109.html#section-2
    cookie[name]["max-age"] = 3600
    # For localhost:16000 this is False # cookie['oauth']['secure'] = True
    cookie[name]["version"] = 1
    cookie[name]["httponly"] = True
    cookie[name]["samesite"] = "Strict"
    parts = cookie.output().split(": ")
    http.response.headers[parts[0].lower()] = ": ".join(parts[1:])
    # Should check already set?
    http.response.headers["cache-control"] = 'no-cache="set-cookie"'
    return session


def oauth_login(http):
    session_id = _get_session_id(http, "oauth")
    if not session_id:
        raise Exception('Not signed in')
    sub = ""
    if http.request.method == "post":
        form = urllib.parse.parse_qs(
            http.request.body.decode("utf8"),
            keep_blank_values=False,
            strict_parsing=True,
            encoding="utf-8",
            max_num_fields=10,
            separator="&",
        )
        subs = form.get("sub", [])
        if len(subs) == 1:
            sub = subs[0]
    if http.request.method == "get" or not sub:
        form = Markup(
            """
            <form method="post">
                <input type="text" name="sub" placeholder="sub" value="{sub}">
                <input type="submit">
            </form>
            <p>Session ID is: {session_id}"""
        ).format(session_id=session_id, sub=sub)
        http.response.body = render_main(title="Login", body=form)
    else:
        session = get_session_value(session_id)
        set_code_sub(session.code, sub)
        # XXX This should actually lookup consent, and if needed redirect to the consent screen

        url = _make_url(session.code, get_code_value(session.code))
        http.response.status = "302 Redirect"
        http.response.headers["location"] = url
        http.response.body = "Redirecting ..."


def oauth_consent(http):
    http.response.body = render_main(
        title="Not yet", body="Need to ask for consent here."
    )
